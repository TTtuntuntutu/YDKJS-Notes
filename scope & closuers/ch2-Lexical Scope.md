### 词法作用域

JavaScript 作用域工作方式的模型，被称为 词法作用域。

#### 词法分析时

词法作用域是由你，在写程序时，变量和作用域的块儿在何处编写<u>决定</u>的，在词法分析时被<u>定义</u>编译的第一步）。

##### 查询

比如这段代码：

```javascript
function foo(a) {

	var b = a * 2;

	function bar(c) {
		console.log( a, b, c );
	}

	bar(b * 3);
}

foo( 2 ); // 2 4 12
```

这里就存在三个嵌套的作用域 全局作用域、`foo`作用域、`bar`作用域。

查询一个变量，会从最内部的作用域开始，如果找不到会到外面最近的下一个作用域，**一旦找到第一个匹配，作用域查询就停止了**。

所以如果最内部的作用域存在变量`a`，外面某个作用域也存在变量`a`，外面作用域的`a`就会被 ***遮蔽*** 。全局变量也自动地是全局对象的属性，如果全局作用域下也有`a`，是可以通过`window.a` 去访问的。

**另外**， 词法作用域查询 *仅仅* 在**处理头等标识符**时实施，比如 `a`，`b`，和 `c`。如果你在一段代码中拥有一个 `foo.bar.baz` 的引用，词法作用域查询将在查找 `foo` 标识符时实施，但一旦定位这个变量，**对象属性访问规则**将会分别接管 `bar` 和 `baz` 属性的解析。

#### 欺骗词法作用域

JavaScript 有两种机制在**运行时修改**（也就是，作弊欺骗） 词法作用域。但是重要的一点是，**欺骗词法作用域会导致更低下的性能。**

##### `eval`

`eval`函数接收一个字符串作为参数值，通常被用于执行动态创建的代码，也就是有可能在执行阶段，修改作用域。比如：

```javascript
function foo(str, a) {
	eval( str ); // 作弊！
	console.log( a, b );
}

var b = 2;

foo( "var b = 3;", 1 ); // 1 3
```

##### `with`

`with` 常见方式是引用一个对象的多个属性，比如：

```javascript
var obj = {
	a: 1,
	b: 2,
	c: 3
};

//  重复“obj”显得更“繁冗”
obj.a = 2;
obj.b = 3;
obj.c = 4;

// “更简单”的缩写
with (obj) {
	a = 3;
	b = 4;
	c = 5;
}
```

`with` 在这里做的事情与 作用域有什么关系？再看另一个demo：

```javascript
function foo(obj) {
	with (obj) {
		a = 2;
	}
}

var o1 = {
	a: 3
};

var o2 = {
	b: 3
};

foo( o1 );
console.log( o1.a ); // 2

foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2 -- 哦，全局作用域被泄漏了！
```

揭秘啦：`with` 语句接收一个对象，这个对象有0个或多个属性，并 **将这个对象视为好像它是一个完全隔离的词法作用域**，因此这个对象的属性被视为在这个“作用域”中词法定义的标识符。

**注意：** 尽管一个 `with` 块儿将一个对象视为一个词法作用域，但是在 `with` 块儿内部的一个普通 `var` 声明将不会归于这个 `with` 块儿的作用域，而是归于包含它的函数作用域。

与 `eval` 去修改作用域不同，`with` 凭空创造了一个 **全新的词法作用域**。

所以在上述例子中，`a` 在 `obj`作用域、`foo`作用域、全局作用域都没有查询到，最后在全局作用域创建了一个全局变量`a`。

##### 严格模式

严格模式下，`eval`可以使用但不允许定义新的变量，以修改作用域；`with`不可以使用。

##### 性能

JavaScript *引擎* 在编译阶段期行许多性能优化工作。其中的一些优化原理都归结为实质上在进行词法分析时可以静态地分析代码，并提前决定所有的变量和函数声明都在什么位置，这样在执行期间就可以少花些力气来解析标识符。

如果使用`eval`和`with`有可能会破坏这个性能优化，导致代码运行更慢。





