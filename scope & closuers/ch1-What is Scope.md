### 什么是作用域

程序最基础的模型：在变量中存储值和取出值。这赋予了程序 *状态* 。

作用域是一组明确定义的规则，定义如何在某些位置**存储变量**，以及如何**找到这些变量**。

作用域规则是在哪里、如何被设置？

#### 编译器理论

JavaScript 一般被划分到 "动态"或者“解释型” 语言的范畴，这是不对的，**它其实是一个编译型语言。**



JavaScript和传统的编译型语言一样，代码在执行之前经历三个步骤，称为“编译”：

1. 分词/词法分析：将一连串字符串打断成 ***token*** ，比如`var a = 2;`，打断成 `var`、`a`、`=`、`2`、`;`

2. 解析：将一个token流转换为一个 ***“抽象语法树”*** ，它综合地表示了程序的语法结构。`var = 2`的树也许是：

   `VariableDeclaration`（变量声明）

   - `Identifier`（标识符）：值为`a`
   - `AssignmentExpression`（复制）
     - `NumbericLiteral`（数字字面量）：值为`2`

3. 代码生成：根据抽象语法树生成 ***机器指令 （可执行代码）***



JavaScript和传统的编译型语言不一样的地方（也可能是被误解为解释型语言的原因）：JS引擎没有大把的时间去优化，编译不是前发生在一个构建的步骤中。往往编译发生在代码被执行前的仅仅几微秒之内（或更少！），当然JS引擎是优化的，在这个短暂的时间将使用所有的招数。

#### 理解作用域

##### 演员

引擎：调用编译器编译、执行代码

编译器：编译（分词/词法分析、解析、代码生成三步走）

作用域：收集和维护变量列表，对代码访问变量实施一组严格规则

##### 编译器/作用域对话，引擎/作用域对话

还是以`var a = 2`为例。

编译器编译在经历分词/词法分析、解析等步骤来到一个十字路口，它会将`var a = 2`拆分为`var a`和`a = 2`。`var a `涉及编译器和作用域的对话，查询**当前这个特定的作用域**，如果`a`存在，忽略`a`的声明，否则，声明`a`。在确保`a`是存在的情况下，将`a = 2`交付给引擎执行。

引擎执行`a = 2`，涉及引擎和作用域的对话，查询**当前作用域**，如果`a` 在当前作用域存在，引用`a`，并且赋值`2`；如果`a`在当前作用域不存在，引擎会在**咨询下一个外层作用域**。

引擎/作用域对话涉及两个编译器术语：*LHS* 和 *RHS*。 比如：

```javascript
var a = 2;	//LHS
console.log(a); //RHS
```

LHS、RHS 都是查询作用域中的变量。LHS 在于找到**变量容器**本身，再将值赋给这个变量容器；而 RHS 在于去取得变量的值，去用这个值。

##### 嵌套作用域

就像一个代码块儿或函数被嵌套在另一个代码块儿或函数中一样，作用域被嵌套在其他的作用域中。所以，如果在直接作用域中找不到一个变量的话，*引擎* 就会咨询下一个外层作用域，如此继续直到找到这个变量或者到达最外层作用域（也就是全局作用域）

#### 错误：`ReferenceError`&`TypeError`

在变量没有声明的情况下，RHS、LHS 两种类型的查询结果是不一样的：

```javascript
function foo(a) {
	console.log( a + b );
	b = a;
}

foo( 2 );
```

这里`b`是一个未声明变量，在`console.log(a+b)`做 RHS 查询找不到，抛出 `ReferenceError`。

而 LHS 在非严格模式下，如果查询找不到，会在全局作用域创建一个同名的新变量，之后返回给引擎。而在严格模式下，也是会抛出 `ReferenceError`。

另外如果在查询得到变量`b`之后，去**做这个值不能做到的事**，就会抛出 `TypeError` 。

**Sum:** `ReferenceError` 是关于 *作用域* 解析失败的，而 `TypeError` 暗示着 *作用域* 解析成功了，但是试图对这个结果进行了一个非法/不可能的动作。